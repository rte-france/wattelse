#  Copyright (c) 2024, RTE (https://www.rte-france.com)
#  See AUTHORS.txt
#  SPDX-License-Identifier: MPL-2.0
#  This file is part of Wattelse, a NLP application suite.
import os
import time

import requests
import urllib3
from starlette import status

# Disable warnings related to https certificates
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class APIClient:
    """
    Generic API client, provides the basic security features
    """

    def __init__(
        self,
        url: str,
        client_id: str = "wattelse",
        client_secret: str = os.getenv("WATTELSE_CLIENT_SECRET", None),
    ):
        self.url = url
        # for authentification
        self.client_id = client_id
        self.client_secret = client_secret
        self.token = None
        self.token_expiry = 0  # Timestamp of when the token expires
        if self.client_secret is None:
            raise ValueError("client_secret must be set")

    def _get_headers(self):
        """Helper function to get headers with authentification token"""
        # Check if the token is still valid
        if self.token is None or time.time() >= self.token_expiry:
            self._get_access_token()
        # Use the token to call a protected endpoint
        headers = {"Authorization": f"Bearer {self.token}"}
        return headers

    def _get_access_token(self, scope: str = None):
        """Obtain an access token using the client credentials flow"""
        token_url = f"{self.url}/token"
        response = requests.post(
            token_url,
            data={
                "username": self.client_id,  # Send client_id as username
                "password": self.client_secret,  # Send client_secret as password
                "scope": scope,  # Requesting specific scopes
            },
            verify=False,  # verify=False to avoid problems of certificate not generated by a trusted CA
        )

        if response.status_code == status.HTTP_200_OK:
            token_data = response.json()
            access_token = token_data["access_token"]
            expires_in = token_data.get(
                "expires_in", 3600
            )  # Default to 1 hour if expires_in is not provided

            # Set the token and its expiry time (current time + expires_in)
            self.token = access_token
            self.token_expiry = time.time() + expires_in
        else:
            raise Exception(
                f"Failed to obtain token: {response.status_code} {response.text}"
            )
